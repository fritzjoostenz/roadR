% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sub_sectioning_v1.R
\name{rr_get_subsections_v1}
\alias{rr_get_subsections_v1}
\title{Gets optimal subsections using Looping method}
\usage{
rr_get_subsections_v1(
  df,
  section_min,
  section_max,
  min_length,
  max_length,
  score_threshold,
  benefit_scaler,
  method = "npv",
  max_subsecs = 25,
  show_progress = TRUE
)
}
\arguments{
\item{df}{data frame with deficit data for the segment. This data frame
should contain all distresses or data relating to capacity deficits, and
should contain the following columns:
\enumerate{
\item section_id: containing the unique ID for sections
\item loc_from: start location for each deficit observation
\item loc_to: end location for each deficit observation
\item deficit: normalised deficit score for each observation. It is
recommended that a scale of 0 to 10 be used, with higher values indicating
greater deficit (distress or capacity deficit)
\item data_code: short code identifying each data type in the set
}}

\item{section_min}{minimum location for the segment}

\item{section_max}{maximum location for the segment}

\item{min_length}{minimum sub-section length allowed}

\item{max_length}{maximum sub-section length allowed}

\item{score_threshold}{lower threshold below which sub-sections should be
ignored}

\item{benefit_scaler}{maximum location for the segment}

\item{method}{method to use for calculating optimal sub-sectioning. Valid
values are 'npv' or 'bcr'. The 'npv' method is recommended. 'bcr' tends to
give very short sub-sections}

\item{max_subsecs}{maximum number of sub-sections to allow within the
section (default is 25)}

\item{show_progress}{TRUE/FALSE flag determining if messages should show the
search progress. Set this to FALSE if you are calling this method in a loop}
}
\value{
TRUE or FALSE
}
\description{
\code{rr_get_subsections_v1} Searches for the optimal subsections within a
section This version uses a sequential looping method starting with a large
search grid and then going sequentially smaller. Gives roughly the same
results as Genetic Algorithm but more consistent and potentially faster
}
